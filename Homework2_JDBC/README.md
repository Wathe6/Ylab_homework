# Ylab_homework
Домашная работа №2 JDBC.
Разработал Пустовой В. А.
SDK: liberica-17 version 17.0.8
Сборщик: Gradle
Тесты выполнены с помощью библиотеки Junit5, AssertJ и TestContainers.
Docker файл - docker-compose.yml 
Почта и пароль для стартового аккаунта:
admin@example.com
admin123

––––––––ДОКУМЕНТАЦИЯ––––––––
Модель состоит из 3 классов - Account, Habit и Statistic.
Account отвечает из профиль пользователя - id, почту, пароль, ник и роль.
Habit содержит id, accountId, название, описание и период для отметки.
Statistic содержит id, habitId, дату и статус отметки (true, false, null).

Для работы с БД был создан конфиг файл - LiquibaseConfig, который при инициализации создаёт подключение. 
С его помощью DAO получают доступ к БД.

Для работы с данными были созданы 3 DAO класс - AccountDAO, HabitDAO, StaticticDAO. А также абстрактный класс BasicDAO, реализующий общие для методов классы.

Классы сервисы содержат методы для работы с DAO. BasicService реализует общие для методов функции.

5 классов Menu позволяют управлять приложением - MainMenu, которое хранит все сервисы и при инициализации подключает их к БД. Также оно вызывает остальные меню.
AuthMenu отвечает за регистрацию или вход пользователя. 
AccountMenu позволяет редактировать почту, пароль, ник.
HabitMenu отмечает привычки, а также даёт возможность добавлять новые и редактировать старые или удалять их.
StatisticMenu выводит информацию о отмеченных привычках - фильтрует по статусу, дате или привычке. Выводит процент выполнения или стрики.

По адресу resources/db/changelog/ находятся liquibase chainlogs.
init.xml создаёт схему.
001 создаёт таблицы, 002 добавляет foreign keys таблицам, 003 добавляет базовые данные - первый профиль, привычку к нему и 1 день статистики.
liquibaseProperties находятся по адресу resources/properies/ и содержат данные для подключения к БД.

Класс in/Input содержит методы для удобного чтения данных и валидации данных.

Возможности для улучшения:
 Изменить период с дней на часы, что позволит увеличить число возможных использований.
 Реализовать dependency injection.
 Использовать UUID вместо Id.
 Вынести статус в перечисление, чтобы можно было расширять (сейчас на тройной логике добавление новых состояний невозможно).

Решения при проектировании (оправдания):
От id можно отказаться в пользу использования составных ключей (surrogate key):
для Account это почта;
для Habit это accountId + name;
для Statistic это habitId + date.
но работать с 1 числом проще, чем со строками.
Бизнес-логика реализована как в Service, так и в Menu что не очень хорошо. Но отделять ввод и циклы от прочего очень неудобно, особенно в Statistic.
Я опять не успел сделать панель администратора.
В прошлом ДЗ я умудрился сохранить документацию в README.dm вместо .md, из-за чего её не было видно...
